<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    function Cat(name) {
        this.name = name;
    }

    var tom = new Cat("汤姆");
    // 目的：把say方法放在tom的原型对象中
    Cat.prototype.say = function () {

    }

    Cat.prototype.s1 =function() {};
    Cat.prototype.s2 =function() {};
    Cat.prototype.s3 =function() {};
    Cat.prototype.s4 =function() {};
    Cat.prototype.s5 =function() {};
    Cat.prototype.s6 =function() {};
    Cat.prototype.s7 =function() {};
    // 通过上面的方式，给tom对象添加了很多方法，也就是让tom拥有了好多方法，但是代码产生了不少的冗余（重复）
    // 为了减少这种重复，改良版：
    Cat.prototype = {
        a1: function() {},
        a2: function() {},
        a3: function() {},
        a4: function() {},
        a5: function() {}
    }

    console.log(tom.s1);
    console.log(tom.a1); // undefined

    var s = new Cat("ss");
    console.log(s.s1);
    console.log(s.a1);

    // 原因：tom对象在创建的时候已经有了一个确定的原型对象，就是旧的Cat.prototype

    // 由于Cat.prototype后面被重新赋值，但是tom对象的原型对象却没有改变，所以tom对象不能访问到新原型对象中的a1-a5方法

    // 如何解决？
    // 先改变原型，再创建对象

</script>
</body>
</html>